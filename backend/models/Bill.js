import mongoose from 'mongoose';

const billSchema = new mongoose.Schema({
  // Basic Bill Information
  billNumber: {
    type: String,
    required: [true, 'Bill number is required'],
    unique: true,
    trim: true
  },
  billType: {
    type: String,
    enum: ['maintenance', 'special_assessment', 'penalty', 'other'],
    default: 'maintenance',
    required: [true, 'Bill type is required']
  },
  
  // Resident and Property Information
  residentId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Resident ID is required']
  },
  flatNumber: {
    type: String,
    required: [true, 'Flat number is required'],
    trim: true
  },
  building: {
    type: String,
    trim: true
  },
  societyName: {
    type: String,
    required: [true, 'Society name is required'],
    trim: true
  },

  // Billing Period
  billingPeriod: {
    month: {
      type: Number,
      required: [true, 'Billing month is required'],
      min: 1,
      max: 12
    },
    year: {
      type: Number,
      required: [true, 'Billing year is required'],
      min: 2020
    }
  },

  // Amount Details
  amount: {
    baseAmount: {
      type: Number,
      required: [true, 'Base amount is required'],
      min: 0
    },
    taxes: {
      type: Number,
      default: 0,
      min: 0
    },
    lateFee: {
      type: Number,
      default: 0,
      min: 0
    },
    otherCharges: {
      type: Number,
      default: 0,
      min: 0
    },
    discount: {
      type: Number,
      default: 0,
      min: 0
    },
    totalAmount: {
      type: Number,
      min: 0
    }
  },

  // Dates
  generatedDate: {
    type: Date,
    default: Date.now
  },
  dueDate: {
    type: Date,
    required: [true, 'Due date is required']
  },
  
  // Status and Payment
  status: {
    type: String,
    enum: ['pending', 'paid', 'partially_paid', 'overdue', 'cancelled'],
    default: 'pending'
  },
  paymentStatus: {
    type: String,
    enum: ['unpaid', 'paid', 'partially_paid', 'failed'],
    default: 'unpaid'
  },
  paidAmount: {
    type: Number,
    default: 0,
    min: 0
  },
  paymentDate: Date,
  paymentMethod: {
    type: String,
    enum: ['razorpay', 'bank_transfer', 'cash', 'cheque', 'other']
  },

  // Description and Notes
  description: {
    type: String,
    trim: true,
    maxlength: [500, 'Description cannot exceed 500 characters']
  },
  notes: {
    type: String,
    trim: true,
    maxlength: [1000, 'Notes cannot exceed 1000 characters']
  },

  // Bill Items (for detailed breakdown)
  items: [{
    name: {
      type: String,
      required: [true, 'Item name is required'],
      trim: true
    },
    description: {
      type: String,
      trim: true
    },
    amount: {
      type: Number,
      required: [true, 'Item amount is required'],
      min: 0
    },
    quantity: {
      type: Number,
      default: 1,
      min: 0
    },
    rate: {
      type: Number,
      default: 0,
      min: 0
    }
  }],

  // Reminders and Notifications
  remindersSent: [{
    type: Date
  }],
  lastReminderSent: Date,
  
  // Admin Information
  generatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Generated by admin ID is required']
  },
  modifiedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },

  // Loyalty Program Tracking
  consecutivePaymentMonth: {
    type: Number,
    default: 0,
    min: 0
  },
  isLoyaltyEligible: {
    type: Boolean,
    default: false
  },
  loyaltyDiscountApplied: {
    type: Number,
    default: 0,
    min: 0
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Indexes for better performance
billSchema.index({ residentId: 1, 'billingPeriod.year': 1, 'billingPeriod.month': 1 });
billSchema.index({ flatNumber: 1, societyName: 1 });
billSchema.index({ status: 1 });
billSchema.index({ paymentStatus: 1 });
billSchema.index({ dueDate: 1 });
billSchema.index({ generatedDate: 1 });

// Virtual for checking if bill is overdue
billSchema.virtual('isOverdue').get(function() {
  return this.status === 'pending' && new Date() > this.dueDate;
});

// Virtual for remaining amount
billSchema.virtual('remainingAmount').get(function() {
  return Math.max(0, this.amount.totalAmount - this.paidAmount);
});

// Virtual for bill period display
billSchema.virtual('billingPeriodDisplay').get(function() {
  const months = [
    'January', 'February', 'March', 'April', 'May', 'June',
    'July', 'August', 'September', 'October', 'November', 'December'
  ];
  return `${months[this.billingPeriod.month - 1]} ${this.billingPeriod.year}`;
});

// Pre-save middleware to calculate total amount
billSchema.pre('save', function(next) {
  // Ensure amount object exists
  if (!this.amount) {
    this.amount = {};
  }
  
  // Calculate total amount from components with defaults
  const baseAmount = this.amount.baseAmount || 0;
  const taxes = this.amount.taxes || 0;
  const lateFee = this.amount.lateFee || 0;
  const otherCharges = this.amount.otherCharges || 0;
  const discount = this.amount.discount || 0;
  
  this.amount.totalAmount = baseAmount + taxes + lateFee + otherCharges - discount;
  
  // Update status based on payment
  if (this.paidAmount >= this.amount.totalAmount) {
    this.status = 'paid';
    this.paymentStatus = 'paid';
  } else if (this.paidAmount > 0) {
    this.status = 'partially_paid';
    this.paymentStatus = 'partially_paid';
  } else if (new Date() > this.dueDate) {
    this.status = 'overdue';
  }
  
  next();
});

// Static method to generate unique bill number
billSchema.statics.generateBillNumber = async function(societyName, year, month) {
  const prefix = societyName.substring(0, 3).toUpperCase();
  const yearMonth = `${year}${month.toString().padStart(2, '0')}`;
  
  // Find the last bill number for this society and period
  const lastBill = await this.findOne({
    societyName: societyName,
    'billingPeriod.year': year,
    'billingPeriod.month': month
  }).sort({ billNumber: -1 });
  
  let sequence = 1;
  if (lastBill && lastBill.billNumber) {
    const lastSequence = parseInt(lastBill.billNumber.split('-').pop());
    sequence = lastSequence + 1;
  }
  
  return `${prefix}-${yearMonth}-${sequence.toString().padStart(4, '0')}`;
};

// Static method to get bills by resident
billSchema.statics.getResidentBills = async function(residentId, options = {}) {
  const {
    page = 1,
    limit = 10,
    status,
    paymentStatus,
    year,
    month,
    sortBy = 'generatedDate',
    sortOrder = 'desc'
  } = options;
  
  const query = { residentId };
  
  if (status) query.status = status;
  if (paymentStatus) query.paymentStatus = paymentStatus;
  if (year) query['billingPeriod.year'] = year;
  if (month) query['billingPeriod.month'] = month;
  
  const sort = {};
  sort[sortBy] = sortOrder === 'desc' ? -1 : 1;
  
  const bills = await this.find(query)
    .populate('residentId', 'firstName lastName email phone')
    .populate('generatedBy', 'firstName lastName')
    .sort(sort)
    .limit(limit * 1)
    .skip((page - 1) * limit);
  
  const total = await this.countDocuments(query);
  
  return {
    bills,
    totalPages: Math.ceil(total / limit),
    currentPage: page,
    total
  };
};

// Static method for bulk bill generation
billSchema.statics.generateBulkBills = async function(billsData) {
  const results = {
    success: [],
    errors: []
  };
  
  for (const billData of billsData) {
    try {
      const bill = new this(billData);
      await bill.save();
      results.success.push(bill);
    } catch (error) {
      results.errors.push({
        billData,
        error: error.message
      });
    }
  }
  
  return results;
};

const Bill = mongoose.model('Bill', billSchema);

export default Bill;
